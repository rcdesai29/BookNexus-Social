{"ast":null,"code":"import{useEffect,useState}from'react';import{UserBookListService}from'../app/services/services/UserBookListService';import{useAuth}from'./useAuth';export function useUserBookList(listType){const{isLoggedIn}=useAuth();const[data,setData]=useState([]);const[loading,setLoading]=useState(true);const[error,setError]=useState(null);const fetchData=async()=>{if(!isLoggedIn){setLoading(false);setError(null);setData([]);return;}setLoading(true);setError(null);try{let result;if(listType){// Fetch specific list type\nresult=await UserBookListService.getUserBooksByListType(listType);}else{// Fetch all books across all lists\nresult=await UserBookListService.getAllUserBooks();}setData(result);}catch(err){setError(err);}finally{setLoading(false);}};useEffect(()=>{fetchData();},[isLoggedIn,listType]);const refetch=()=>{fetchData();};const moveToShelf=async(bookId,fromShelf,toShelf)=>{try{// Remove from current shelf\nawait UserBookListService.removeGoogleBookFromList(bookId,fromShelf);// Add to new shelf\nawait UserBookListService.addGoogleBookToList(bookId,toShelf);// Refresh data\nawait fetchData();}catch(error){console.error('Failed to move book to shelf:',error);throw error;}};const removeFromLibrary=async bookId=>{try{// Find the book to determine its current shelf\nconst book=data.find(item=>{var _item$googleBook,_item$book,_item$book$id;return((_item$googleBook=item.googleBook)===null||_item$googleBook===void 0?void 0:_item$googleBook.googleBookId)===bookId||((_item$book=item.book)===null||_item$book===void 0?void 0:(_item$book$id=_item$book.id)===null||_item$book$id===void 0?void 0:_item$book$id.toString())===bookId;});if(book&&book.listType){await UserBookListService.removeGoogleBookFromList(bookId,book.listType);// Refresh data\nawait fetchData();}}catch(error){console.error('Failed to remove book from library:',error);throw error;}};const markAsFinished=async bookId=>{try{// Move from currently reading to read\nawait moveToShelf(bookId,'CURRENTLY_READING','READ');}catch(error){console.error('Failed to mark book as finished:',error);throw error;}};return{data,loading,error,refetch,moveToShelf,removeFromLibrary,markAsFinished};}","map":{"version":3,"names":["useEffect","useState","UserBookListService","useAuth","useUserBookList","listType","isLoggedIn","data","setData","loading","setLoading","error","setError","fetchData","result","getUserBooksByListType","getAllUserBooks","err","refetch","moveToShelf","bookId","fromShelf","toShelf","removeGoogleBookFromList","addGoogleBookToList","console","removeFromLibrary","book","find","item","_item$googleBook","_item$book","_item$book$id","googleBook","googleBookId","id","toString","markAsFinished"],"sources":["/Users/cluckbucks/projects/booknexus-social/frontend/src/hooks/useUserBookList.ts"],"sourcesContent":["import { useEffect, useState } from 'react';\nimport { UserBookList, UserBookListService } from '../app/services/services/UserBookListService';\nimport { useAuth } from './useAuth';\n\nexport function useUserBookList(listType?: 'FAVORITE' | 'CURRENTLY_READING' | 'TBR' | 'READ') {\n  const { isLoggedIn } = useAuth();\n  const [data, setData] = useState<UserBookList[]>([]);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<any>(null);\n\n  const fetchData = async () => {\n    if (!isLoggedIn) {\n      setLoading(false);\n      setError(null);\n      setData([]);\n      return;\n    }\n    \n    setLoading(true);\n    setError(null);\n    \n    try {\n      let result: UserBookList[];\n      \n      if (listType) {\n        // Fetch specific list type\n        result = await UserBookListService.getUserBooksByListType(listType);\n      } else {\n        // Fetch all books across all lists\n        result = await UserBookListService.getAllUserBooks();\n      }\n      \n      setData(result);\n    } catch (err) {\n      setError(err);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    fetchData();\n  }, [isLoggedIn, listType]);\n\n  const refetch = () => {\n    fetchData();\n  };\n\n  const moveToShelf = async (bookId: string, fromShelf: string, toShelf: string) => {\n    try {\n      // Remove from current shelf\n      await UserBookListService.removeGoogleBookFromList(bookId, fromShelf as any);\n      // Add to new shelf\n      await UserBookListService.addGoogleBookToList(bookId, toShelf as any);\n      // Refresh data\n      await fetchData();\n    } catch (error) {\n      console.error('Failed to move book to shelf:', error);\n      throw error;\n    }\n  };\n\n  const removeFromLibrary = async (bookId: string) => {\n    try {\n      // Find the book to determine its current shelf\n      const book = data.find(item => \n        (item.googleBook?.googleBookId === bookId) || \n        (item.book?.id?.toString() === bookId)\n      );\n      \n      if (book && book.listType) {\n        await UserBookListService.removeGoogleBookFromList(bookId, book.listType);\n        // Refresh data\n        await fetchData();\n      }\n    } catch (error) {\n      console.error('Failed to remove book from library:', error);\n      throw error;\n    }\n  };\n\n  const markAsFinished = async (bookId: string) => {\n    try {\n      // Move from currently reading to read\n      await moveToShelf(bookId, 'CURRENTLY_READING', 'READ');\n    } catch (error) {\n      console.error('Failed to mark book as finished:', error);\n      throw error;\n    }\n  };\n\n  return { \n    data, \n    loading, \n    error, \n    refetch, \n    moveToShelf, \n    removeFromLibrary, \n    markAsFinished \n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}