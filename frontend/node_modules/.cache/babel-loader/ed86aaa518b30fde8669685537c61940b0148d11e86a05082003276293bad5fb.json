{"ast":null,"code":"/* generated using openapi-typescript-codegen -- do not edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport { ApiError } from './ApiError';\nimport { CancelablePromise } from './CancelablePromise';\nexport const isDefined = value => {\n  return value !== undefined && value !== null;\n};\nexport const isString = value => {\n  return typeof value === 'string';\n};\nexport const isStringWithValue = value => {\n  return isString(value) && value !== '';\n};\nexport const isBlob = value => {\n  return typeof value === 'object' && typeof value.type === 'string' && typeof value.stream === 'function' && typeof value.arrayBuffer === 'function' && typeof value.constructor === 'function' && typeof value.constructor.name === 'string' && /^(Blob|File)$/.test(value.constructor.name) && /^(Blob|File)$/.test(value[Symbol.toStringTag]);\n};\nexport const isFormData = value => {\n  return value instanceof FormData;\n};\nexport const base64 = str => {\n  try {\n    return btoa(str);\n  } catch (err) {\n    // @ts-ignore\n    return Buffer.from(str).toString('base64');\n  }\n};\nexport const getQueryString = params => {\n  const qs = [];\n  const append = (key, value) => {\n    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);\n  };\n  const process = (key, value) => {\n    if (isDefined(value)) {\n      if (Array.isArray(value)) {\n        value.forEach(v => {\n          process(key, v);\n        });\n      } else if (typeof value === 'object') {\n        Object.entries(value).forEach(([k, v]) => {\n          process(`${key}[${k}]`, v);\n        });\n      } else {\n        append(key, value);\n      }\n    }\n  };\n  Object.entries(params).forEach(([key, value]) => {\n    process(key, value);\n  });\n  if (qs.length > 0) {\n    return `?${qs.join('&')}`;\n  }\n  return '';\n};\nconst getUrl = (config, options) => {\n  const encoder = config.ENCODE_PATH || encodeURI;\n  const path = options.url.replace('{api-version}', config.VERSION).replace(/{(.*?)}/g, (substring, group) => {\n    var _options$path;\n    if ((_options$path = options.path) !== null && _options$path !== void 0 && _options$path.hasOwnProperty(group)) {\n      return encoder(String(options.path[group]));\n    }\n    return substring;\n  });\n  const url = `${config.BASE}${path}`;\n  if (options.query) {\n    return `${url}${getQueryString(options.query)}`;\n  }\n  return url;\n};\nexport const getFormData = options => {\n  if (options.formData) {\n    const formData = new FormData();\n    const process = (key, value) => {\n      if (isString(value) || isBlob(value)) {\n        formData.append(key, value);\n      } else {\n        formData.append(key, JSON.stringify(value));\n      }\n    };\n    Object.entries(options.formData).filter(([_, value]) => isDefined(value)).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        value.forEach(v => process(key, v));\n      } else {\n        process(key, value);\n      }\n    });\n    return formData;\n  }\n  return undefined;\n};\nexport const resolve = async (options, resolver) => {\n  if (typeof resolver === 'function') {\n    return resolver(options);\n  }\n  return resolver;\n};\nexport const getHeaders = async (config, options) => {\n  const [token, username, password, additionalHeaders] = await Promise.all([resolve(options, config.TOKEN), resolve(options, config.USERNAME), resolve(options, config.PASSWORD), resolve(options, config.HEADERS)]);\n  const headers = Object.entries({\n    Accept: 'application/json',\n    ...additionalHeaders,\n    ...options.headers\n  }).filter(([_, value]) => isDefined(value)).reduce((headers, [key, value]) => ({\n    ...headers,\n    [key]: String(value)\n  }), {});\n  if (isStringWithValue(token)) {\n    headers['Authorization'] = `Bearer ${token}`;\n  }\n  if (isStringWithValue(username) && isStringWithValue(password)) {\n    const credentials = base64(`${username}:${password}`);\n    headers['Authorization'] = `Basic ${credentials}`;\n  }\n  if (options.body !== undefined) {\n    if (options.mediaType) {\n      headers['Content-Type'] = options.mediaType;\n    } else if (isBlob(options.body)) {\n      headers['Content-Type'] = options.body.type || 'application/octet-stream';\n    } else if (isString(options.body)) {\n      headers['Content-Type'] = 'text/plain';\n    } else if (!isFormData(options.body)) {\n      headers['Content-Type'] = 'application/json';\n    }\n  }\n  return new Headers(headers);\n};\nexport const getRequestBody = options => {\n  if (options.body !== undefined) {\n    var _options$mediaType;\n    if ((_options$mediaType = options.mediaType) !== null && _options$mediaType !== void 0 && _options$mediaType.includes('/json')) {\n      return JSON.stringify(options.body);\n    } else if (isString(options.body) || isBlob(options.body) || isFormData(options.body)) {\n      return options.body;\n    } else {\n      return JSON.stringify(options.body);\n    }\n  }\n  return undefined;\n};\nexport const sendRequest = async (config, options, url, body, formData, headers, onCancel) => {\n  const controller = new AbortController();\n  const request = {\n    headers,\n    body: body !== null && body !== void 0 ? body : formData,\n    method: options.method,\n    signal: controller.signal\n  };\n  if (config.WITH_CREDENTIALS) {\n    request.credentials = config.CREDENTIALS;\n  }\n  onCancel(() => controller.abort());\n  return await fetch(url, request);\n};\nexport const getResponseHeader = (response, responseHeader) => {\n  if (responseHeader) {\n    const content = response.headers.get(responseHeader);\n    if (isString(content)) {\n      return content;\n    }\n  }\n  return undefined;\n};\nexport const getResponseBody = async response => {\n  if (response.status !== 204) {\n    try {\n      const contentType = response.headers.get('Content-Type');\n      if (contentType) {\n        const jsonTypes = ['application/json', 'application/problem+json'];\n        const isJSON = jsonTypes.some(type => contentType.toLowerCase().startsWith(type));\n        if (isJSON) {\n          return await response.json();\n        } else {\n          return await response.text();\n        }\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  }\n  return undefined;\n};\nexport const catchErrorCodes = (options, result) => {\n  const errors = {\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    403: 'Forbidden',\n    404: 'Not Found',\n    500: 'Internal Server Error',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    ...options.errors\n  };\n  const error = errors[result.status];\n  if (error) {\n    throw new ApiError(options, result, error);\n  }\n  if (!result.ok) {\n    var _result$status, _result$statusText;\n    const errorStatus = (_result$status = result.status) !== null && _result$status !== void 0 ? _result$status : 'unknown';\n    const errorStatusText = (_result$statusText = result.statusText) !== null && _result$statusText !== void 0 ? _result$statusText : 'unknown';\n    const errorBody = (() => {\n      try {\n        return JSON.stringify(result.body, null, 2);\n      } catch (e) {\n        return undefined;\n      }\n    })();\n    throw new ApiError(options, result, `Generic Error: status: ${errorStatus}; status text: ${errorStatusText}; body: ${errorBody}`);\n  }\n};\n\n/**\n * Request method\n * @param config The OpenAPI configuration object\n * @param options The request options from the service\n * @returns CancelablePromise<T>\n * @throws ApiError\n */\nexport const request = (config, options) => {\n  return new CancelablePromise(async (resolve, reject, onCancel) => {\n    try {\n      const url = getUrl(config, options);\n      const formData = getFormData(options);\n      const body = getRequestBody(options);\n      const headers = await getHeaders(config, options);\n      if (!onCancel.isCancelled) {\n        const response = await sendRequest(config, options, url, body, formData, headers, onCancel);\n        const responseBody = await getResponseBody(response);\n        const responseHeader = getResponseHeader(response, options.responseHeader);\n        const result = {\n          url,\n          ok: response.ok,\n          status: response.status,\n          statusText: response.statusText,\n          body: responseHeader !== null && responseHeader !== void 0 ? responseHeader : responseBody\n        };\n        catchErrorCodes(options, result);\n        resolve(result.body);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n};","map":{"version":3,"names":["ApiError","CancelablePromise","isDefined","value","undefined","isString","isStringWithValue","isBlob","type","stream","arrayBuffer","constructor","name","test","Symbol","toStringTag","isFormData","FormData","base64","str","btoa","err","Buffer","from","toString","getQueryString","params","qs","append","key","push","encodeURIComponent","String","process","Array","isArray","forEach","v","Object","entries","k","length","join","getUrl","config","options","encoder","ENCODE_PATH","encodeURI","path","url","replace","VERSION","substring","group","_options$path","hasOwnProperty","BASE","query","getFormData","formData","JSON","stringify","filter","_","resolve","resolver","getHeaders","token","username","password","additionalHeaders","Promise","all","TOKEN","USERNAME","PASSWORD","HEADERS","headers","Accept","reduce","credentials","body","mediaType","Headers","getRequestBody","_options$mediaType","includes","sendRequest","onCancel","controller","AbortController","request","method","signal","WITH_CREDENTIALS","CREDENTIALS","abort","fetch","getResponseHeader","response","responseHeader","content","get","getResponseBody","status","contentType","jsonTypes","isJSON","some","toLowerCase","startsWith","json","text","error","console","catchErrorCodes","result","errors","ok","_result$status","_result$statusText","errorStatus","errorStatusText","statusText","errorBody","e","reject","isCancelled","responseBody"],"sources":["/Users/cluckbucks/projects/booknexus-social/frontend/src/app/services/core/request.ts"],"sourcesContent":["/* generated using openapi-typescript-codegen -- do not edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport { ApiError } from './ApiError';\nimport type { ApiRequestOptions } from './ApiRequestOptions';\nimport type { ApiResult } from './ApiResult';\nimport { CancelablePromise } from './CancelablePromise';\nimport type { OnCancel } from './CancelablePromise';\nimport type { OpenAPIConfig } from './OpenAPI';\n\nexport const isDefined = <T>(value: T | null | undefined): value is Exclude<T, null | undefined> => {\n    return value !== undefined && value !== null;\n};\n\nexport const isString = (value: any): value is string => {\n    return typeof value === 'string';\n};\n\nexport const isStringWithValue = (value: any): value is string => {\n    return isString(value) && value !== '';\n};\n\nexport const isBlob = (value: any): value is Blob => {\n    return (\n        typeof value === 'object' &&\n        typeof value.type === 'string' &&\n        typeof value.stream === 'function' &&\n        typeof value.arrayBuffer === 'function' &&\n        typeof value.constructor === 'function' &&\n        typeof value.constructor.name === 'string' &&\n        /^(Blob|File)$/.test(value.constructor.name) &&\n        /^(Blob|File)$/.test(value[Symbol.toStringTag])\n    );\n};\n\nexport const isFormData = (value: any): value is FormData => {\n    return value instanceof FormData;\n};\n\nexport const base64 = (str: string): string => {\n    try {\n        return btoa(str);\n    } catch (err) {\n        // @ts-ignore\n        return Buffer.from(str).toString('base64');\n    }\n};\n\nexport const getQueryString = (params: Record<string, any>): string => {\n    const qs: string[] = [];\n\n    const append = (key: string, value: any) => {\n        qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);\n    };\n\n    const process = (key: string, value: any) => {\n        if (isDefined(value)) {\n            if (Array.isArray(value)) {\n                value.forEach(v => {\n                    process(key, v);\n                });\n            } else if (typeof value === 'object') {\n                Object.entries(value).forEach(([k, v]) => {\n                    process(`${key}[${k}]`, v);\n                });\n            } else {\n                append(key, value);\n            }\n        }\n    };\n\n    Object.entries(params).forEach(([key, value]) => {\n        process(key, value);\n    });\n\n    if (qs.length > 0) {\n        return `?${qs.join('&')}`;\n    }\n\n    return '';\n};\n\nconst getUrl = (config: OpenAPIConfig, options: ApiRequestOptions): string => {\n    const encoder = config.ENCODE_PATH || encodeURI;\n\n    const path = options.url\n        .replace('{api-version}', config.VERSION)\n        .replace(/{(.*?)}/g, (substring: string, group: string) => {\n            if (options.path?.hasOwnProperty(group)) {\n                return encoder(String(options.path[group]));\n            }\n            return substring;\n        });\n\n    const url = `${config.BASE}${path}`;\n    if (options.query) {\n        return `${url}${getQueryString(options.query)}`;\n    }\n    return url;\n};\n\nexport const getFormData = (options: ApiRequestOptions): FormData | undefined => {\n    if (options.formData) {\n        const formData = new FormData();\n\n        const process = (key: string, value: any) => {\n            if (isString(value) || isBlob(value)) {\n                formData.append(key, value);\n            } else {\n                formData.append(key, JSON.stringify(value));\n            }\n        };\n\n        Object.entries(options.formData)\n            .filter(([_, value]) => isDefined(value))\n            .forEach(([key, value]) => {\n                if (Array.isArray(value)) {\n                    value.forEach(v => process(key, v));\n                } else {\n                    process(key, value);\n                }\n            });\n\n        return formData;\n    }\n    return undefined;\n};\n\ntype Resolver<T> = (options: ApiRequestOptions) => Promise<T>;\n\nexport const resolve = async <T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> => {\n    if (typeof resolver === 'function') {\n        return (resolver as Resolver<T>)(options);\n    }\n    return resolver;\n};\n\nexport const getHeaders = async (config: OpenAPIConfig, options: ApiRequestOptions): Promise<Headers> => {\n    const [token, username, password, additionalHeaders] = await Promise.all([\n        resolve(options, config.TOKEN),\n        resolve(options, config.USERNAME),\n        resolve(options, config.PASSWORD),\n        resolve(options, config.HEADERS),\n    ]);\n\n    const headers = Object.entries({\n        Accept: 'application/json',\n        ...additionalHeaders,\n        ...options.headers,\n    })\n        .filter(([_, value]) => isDefined(value))\n        .reduce((headers, [key, value]) => ({\n            ...headers,\n            [key]: String(value),\n        }), {} as Record<string, string>);\n\n    if (isStringWithValue(token)) {\n        headers['Authorization'] = `Bearer ${token}`;\n    }\n\n    if (isStringWithValue(username) && isStringWithValue(password)) {\n        const credentials = base64(`${username}:${password}`);\n        headers['Authorization'] = `Basic ${credentials}`;\n    }\n\n    if (options.body !== undefined) {\n        if (options.mediaType) {\n            headers['Content-Type'] = options.mediaType;\n        } else if (isBlob(options.body)) {\n            headers['Content-Type'] = options.body.type || 'application/octet-stream';\n        } else if (isString(options.body)) {\n            headers['Content-Type'] = 'text/plain';\n        } else if (!isFormData(options.body)) {\n            headers['Content-Type'] = 'application/json';\n        }\n    }\n\n    return new Headers(headers);\n};\n\nexport const getRequestBody = (options: ApiRequestOptions): any => {\n    if (options.body !== undefined) {\n        if (options.mediaType?.includes('/json')) {\n            return JSON.stringify(options.body)\n        } else if (isString(options.body) || isBlob(options.body) || isFormData(options.body)) {\n            return options.body;\n        } else {\n            return JSON.stringify(options.body);\n        }\n    }\n    return undefined;\n};\n\nexport const sendRequest = async (\n    config: OpenAPIConfig,\n    options: ApiRequestOptions,\n    url: string,\n    body: any,\n    formData: FormData | undefined,\n    headers: Headers,\n    onCancel: OnCancel\n): Promise<Response> => {\n    const controller = new AbortController();\n\n    const request: RequestInit = {\n        headers,\n        body: body ?? formData,\n        method: options.method,\n        signal: controller.signal,\n    };\n\n    if (config.WITH_CREDENTIALS) {\n        request.credentials = config.CREDENTIALS;\n    }\n\n    onCancel(() => controller.abort());\n\n    return await fetch(url, request);\n};\n\nexport const getResponseHeader = (response: Response, responseHeader?: string): string | undefined => {\n    if (responseHeader) {\n        const content = response.headers.get(responseHeader);\n        if (isString(content)) {\n            return content;\n        }\n    }\n    return undefined;\n};\n\nexport const getResponseBody = async (response: Response): Promise<any> => {\n    if (response.status !== 204) {\n        try {\n            const contentType = response.headers.get('Content-Type');\n            if (contentType) {\n                const jsonTypes = ['application/json', 'application/problem+json']\n                const isJSON = jsonTypes.some(type => contentType.toLowerCase().startsWith(type));\n                if (isJSON) {\n                    return await response.json();\n                } else {\n                    return await response.text();\n                }\n            }\n        } catch (error) {\n            console.error(error);\n        }\n    }\n    return undefined;\n};\n\nexport const catchErrorCodes = (options: ApiRequestOptions, result: ApiResult): void => {\n    const errors: Record<number, string> = {\n        400: 'Bad Request',\n        401: 'Unauthorized',\n        403: 'Forbidden',\n        404: 'Not Found',\n        500: 'Internal Server Error',\n        502: 'Bad Gateway',\n        503: 'Service Unavailable',\n        ...options.errors,\n    }\n\n    const error = errors[result.status];\n    if (error) {\n        throw new ApiError(options, result, error);\n    }\n\n    if (!result.ok) {\n        const errorStatus = result.status ?? 'unknown';\n        const errorStatusText = result.statusText ?? 'unknown';\n        const errorBody = (() => {\n            try {\n                return JSON.stringify(result.body, null, 2);\n            } catch (e) {\n                return undefined;\n            }\n        })();\n\n        throw new ApiError(options, result,\n            `Generic Error: status: ${errorStatus}; status text: ${errorStatusText}; body: ${errorBody}`\n        );\n    }\n};\n\n/**\n * Request method\n * @param config The OpenAPI configuration object\n * @param options The request options from the service\n * @returns CancelablePromise<T>\n * @throws ApiError\n */\nexport const request = <T>(config: OpenAPIConfig, options: ApiRequestOptions): CancelablePromise<T> => {\n    return new CancelablePromise(async (resolve, reject, onCancel) => {\n        try {\n            const url = getUrl(config, options);\n            const formData = getFormData(options);\n            const body = getRequestBody(options);\n            const headers = await getHeaders(config, options);\n\n            if (!onCancel.isCancelled) {\n                const response = await sendRequest(config, options, url, body, formData, headers, onCancel);\n                const responseBody = await getResponseBody(response);\n                const responseHeader = getResponseHeader(response, options.responseHeader);\n\n                const result: ApiResult = {\n                    url,\n                    ok: response.ok,\n                    status: response.status,\n                    statusText: response.statusText,\n                    body: responseHeader ?? responseBody,\n                };\n\n                catchErrorCodes(options, result);\n\n                resolve(result.body);\n            }\n        } catch (error) {\n            reject(error);\n        }\n    });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}