{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState } from 'react';\nimport { UserBookListService } from '../app/services/services/UserBookListService';\nimport { useAuth } from './useAuth';\nexport function useUserBookList(listType) {\n  _s();\n  const {\n    isLoggedIn\n  } = useAuth();\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const fetchData = async () => {\n    if (!isLoggedIn) {\n      setLoading(false);\n      setError(null);\n      setData([]);\n      return;\n    }\n    setLoading(true);\n    setError(null);\n    try {\n      let result;\n      if (listType) {\n        // Fetch specific list type\n        result = await UserBookListService.getUserBooksByListType(listType);\n      } else {\n        // Fetch all books across all lists\n        result = await UserBookListService.getAllUserBooks();\n      }\n      setData(result || []);\n    } catch (err) {\n      console.error('Error fetching user books:', err);\n      setError(err);\n      // Set empty array on error so user sees empty state instead of error\n      setData([]);\n    } finally {\n      setLoading(false);\n    }\n  };\n  useEffect(() => {\n    fetchData();\n  }, [isLoggedIn, listType]);\n  const refetch = () => {\n    fetchData();\n  };\n  const moveToShelf = async (bookId, fromShelf, toShelf) => {\n    try {\n      // Remove from current shelf\n      await UserBookListService.removeGoogleBookFromList(bookId, fromShelf);\n      // Add to new shelf\n      await UserBookListService.addGoogleBookToList(bookId, toShelf);\n      // Refresh data\n      await fetchData();\n    } catch (error) {\n      console.error('Failed to move book to shelf:', error);\n      throw error;\n    }\n  };\n  const removeFromLibrary = async bookId => {\n    try {\n      // Find the book to determine its current shelf\n      const book = data.find(item => {\n        var _item$googleBook, _item$book, _item$book$id;\n        return ((_item$googleBook = item.googleBook) === null || _item$googleBook === void 0 ? void 0 : _item$googleBook.googleBookId) === bookId || ((_item$book = item.book) === null || _item$book === void 0 ? void 0 : (_item$book$id = _item$book.id) === null || _item$book$id === void 0 ? void 0 : _item$book$id.toString()) === bookId;\n      });\n      if (book && book.listType) {\n        await UserBookListService.removeGoogleBookFromList(bookId, book.listType);\n        // Refresh data\n        await fetchData();\n      }\n    } catch (error) {\n      console.error('Failed to remove book from library:', error);\n      throw error;\n    }\n  };\n  const markAsFinished = async bookId => {\n    try {\n      // Move from currently reading to read\n      await moveToShelf(bookId, 'CURRENTLY_READING', 'READ');\n    } catch (error) {\n      console.error('Failed to mark book as finished:', error);\n      throw error;\n    }\n  };\n  return {\n    data,\n    loading,\n    error,\n    refetch,\n    moveToShelf,\n    removeFromLibrary,\n    markAsFinished\n  };\n}\n_s(useUserBookList, \"6EQXdsde06X2bckWY/kCr/vE5NA=\", false, function () {\n  return [useAuth];\n});","map":{"version":3,"names":["useEffect","useState","UserBookListService","useAuth","useUserBookList","listType","_s","isLoggedIn","data","setData","loading","setLoading","error","setError","fetchData","result","getUserBooksByListType","getAllUserBooks","err","console","refetch","moveToShelf","bookId","fromShelf","toShelf","removeGoogleBookFromList","addGoogleBookToList","removeFromLibrary","book","find","item","_item$googleBook","_item$book","_item$book$id","googleBook","googleBookId","id","toString","markAsFinished"],"sources":["/Users/cluckbucks/projects/booknexus-social/frontend/src/hooks/useUserBookList.ts"],"sourcesContent":["import { useEffect, useState } from 'react';\nimport { UserBookList, UserBookListService } from '../app/services/services/UserBookListService';\nimport { useAuth } from './useAuth';\n\nexport function useUserBookList(listType?: 'FAVORITE' | 'CURRENTLY_READING' | 'TBR' | 'READ') {\n  const { isLoggedIn } = useAuth();\n  const [data, setData] = useState<UserBookList[]>([]);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<any>(null);\n\n  const fetchData = async () => {\n    if (!isLoggedIn) {\n      setLoading(false);\n      setError(null);\n      setData([]);\n      return;\n    }\n    \n    setLoading(true);\n    setError(null);\n    \n    try {\n      let result: UserBookList[];\n      \n      if (listType) {\n        // Fetch specific list type\n        result = await UserBookListService.getUserBooksByListType(listType);\n      } else {\n        // Fetch all books across all lists\n        result = await UserBookListService.getAllUserBooks();\n      }\n      setData(result || []);\n    } catch (err) {\n      console.error('Error fetching user books:', err);\n      setError(err);\n      // Set empty array on error so user sees empty state instead of error\n      setData([]);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    fetchData();\n  }, [isLoggedIn, listType]);\n\n  const refetch = () => {\n    fetchData();\n  };\n\n  const moveToShelf = async (bookId: string, fromShelf: string, toShelf: string) => {\n    try {\n      // Remove from current shelf\n      await UserBookListService.removeGoogleBookFromList(bookId, fromShelf as any);\n      // Add to new shelf\n      await UserBookListService.addGoogleBookToList(bookId, toShelf as any);\n      // Refresh data\n      await fetchData();\n    } catch (error) {\n      console.error('Failed to move book to shelf:', error);\n      throw error;\n    }\n  };\n\n  const removeFromLibrary = async (bookId: string) => {\n    try {\n      // Find the book to determine its current shelf\n      const book = data.find(item => \n        (item.googleBook?.googleBookId === bookId) || \n        (item.book?.id?.toString() === bookId)\n      );\n      \n      if (book && book.listType) {\n        await UserBookListService.removeGoogleBookFromList(bookId, book.listType);\n        // Refresh data\n        await fetchData();\n      }\n    } catch (error) {\n      console.error('Failed to remove book from library:', error);\n      throw error;\n    }\n  };\n\n  const markAsFinished = async (bookId: string) => {\n    try {\n      // Move from currently reading to read\n      await moveToShelf(bookId, 'CURRENTLY_READING', 'READ');\n    } catch (error) {\n      console.error('Failed to mark book as finished:', error);\n      throw error;\n    }\n  };\n\n  return { \n    data, \n    loading, \n    error, \n    refetch, \n    moveToShelf, \n    removeFromLibrary, \n    markAsFinished \n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}